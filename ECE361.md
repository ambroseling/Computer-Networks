
- Internet's way of transmitting information
	- sending packets (application message broken into smaller chunks)
	- access network has transmission rate R
	- `packet transmission delay = L (bits) / R (bits/sec)`
- Internet
	- **hosts** = end systems, runs network applications at internet's edge
	- **packet switches**: 
		- forward packets
		- **forwarding:** local action, move arriving packets from router's input link to appropriate router output link
		- **routing**: determine source-destination paths taken by packets
	- communication links: 
	- access networks
		- we use **residential access nets, institutional access networks mobile access networks** to connect end systems
		- 3 types:
			- Wired
				- cable based access: 
					- uses FDM (frequency division multiplexing) with different frequency bands transmitting different channels
					- internet service provider router connects to homes (network of fibre and cable)
				- digital subscriber line:
					- send voice and data transmitted at different frequencies to central office 
					- DSLAM (Digital Subscriber Line Access Multiplexer) is a network device used by Internet Service Providers (ISPs) to manage and route DSL (Digital Subscriber Line) connections
			- Wireless
				- shared wireless access network connects end system to router
				- 1. wireless local area networks 
					- within or around a building
				- 2. wide area cellular access networks
					- provided by cellular network operators
			- Enterprise
				- mix of wired and wireless, connecting switches and routers
				- has Ethernet and/or Wifi
- Links
	- bits: the thing being propagataed
	- physical media: what lies btw transmitter and receiver
		- coaxial cable: 2 concentric copper conductors, bidirectional
		- fibre optic cable: glass fibre carrying **light pulses** (each pulse is a bit), higher speeds, low error rate (immune to electromag noise)
		- wireless radio
	- guided media: signals propagate in solid media (copper, fiber, coax), has some wire to guide it, signal only can travel inside this medium
	- unguided media: signal can go anywhere, propagate freely (radio)
	- twisted pair
- CDN
	- private networks that connect its data centers to internet

### Circuit Packet Switching
- Delays:
	- Total delay: $d_{nodal} = d_{proc} + d_{queue} + d_{trans} + d_{prop}$
	- **Transmission delay:** 
		- $L/R$ seconds to transmit L bit packet into link at R bits / second
		- $L$: packet length
		- $R:$ link transmission rate
		- $d_{trans} = \frac{L}{R}$
	- **Queueing delay:** wait for previous packet to be transmitted on the output link, we can also drop packets if memory / buffer fills, lost packet can be retransmitted
		- Packet queuing delay:
			- $\rho = \frac{La}{R}$: traffic intensity
				- where $R$: link bandwidth (bps)
				- where $L$: packet length (bits)
				- where $a$: average packet arrival rate 
	- **End to end delay:** $2L/R$ for 1 link for store-forward, $L/R$ for 1 link for cut through
	- **Propagation delay:** 
		- $d$: length of physical link
		- $s$: propagation speed 
		- $d_{prop}=\frac{d}{s}$ 
	- **Nodal Processing delay**:
		- check for bit errors
		- determines output link
- Packet switching
	- Pros: allows more users to use the network
	- Cons: not guaranteed to have bandwidth
	- Store and Forward: 
		- only forward the packet once entire packet is processed
		- entire packet must arrive at router before it can be transmitted on next link
	- Cut through:
		- info about destination is at the header of the packet
	- Delay if there were N routers
		- Packet Switching:
		- 
- Circuit switching
	- Frequency Division Multiplexing
		- electromagnetic frequencies into bands
		- each call allocated its own band
		- each call can transmit max rate of the narrow band (that call must operate in that frequency range)
	- Time Division Multiplexing
		- Each call can use any frequency but only during its time slot
		- Each call allocated periodic slots
	- Pros:  resource is **always*** reserved and dedicated for the call btw source and destination
	- Cons: if resource isn't used its idle, could be wasting the bandwidth, there is no sharing of bandwidth

- Internet Protocol stack
	- 5 layers
		- **application:** support network apps (HTTP, SMTP)
		- **transport:** process-process data transfer
		* **network:** routing of packets 
		* **link:** data transfer btw neighbouring network elements
		* **physical:** bits on the wire
	* Modularization $\rightarrow$ better maintenance, updating of system, explicit structure
* Throughput
	* rate at which bits are being sent from sender to receiver 
	* **instantaneous**: rate at some instant
	* **average**: rate over some period of time
	* per connection end-end throughput (when you have 10 connections with a bottleneck then to multiple servers): $min(R_c,R_s,R/10)$
	* $R_s < R_c$ :
	- $R_s > R_c$ :
	- link on end-end path that constrains end-end throughput

### **Transport Layer Protocols**
- Transport Layer services
	- logical communication btw application process running on different hosts
	- in end systems
		- sender: breaks application message into segments, passes to network layer
		- receiver: reassembles segments into messages, passess to application layer
- Multiplexing(sender) / Demultiplexing (receiver)
	- multiplexing: handle data from multiple sockets, add transport header
	- demultiplexing: use header info to deliver recevied segments to correct process
		- hosts receive IP datagrams which has source IP and destination IP
		- connectionless
			- datagram sent into UDP socket must specify destination IP and port #
			- receiving hosts receive UDP segments, checks destination port # in segment, directs UDP segment to socket with that port #
			- if datagram has same destination port # but different source IP addresses, will be directed to same socket
		- connection oriented
			- tcp socket identified by (source IP, source port, dest IP, dest port)
			- server may support many simultaneous TCP sockets

- Considerations for an app when selecting transport service:
	- Data integrity: some apps require 100% reliable data transfer
	- Timing: some apps require low delay to be effective
	- Throughput: some apps require minimum amount of throughput to be effective
	- Security: encryption

### **Application Layer 
- Application Layer Protocol defines:
	- types of messages exchanged: request, response
	- message syntax: what fields in messsages and how fields are delineated
	- message semantics: meaning of information in fields
	- rules: when and how processes send and respond to messages

### Application Layer Protocols:

**Web Caching**
- reduce response time for client request, cache is closer to client
- reduce traffic on an institutions access link
- internet is dense with caches 
- acts as both client and server (server for original requesting client, client to origin server)
- average end-end delay = cache miss rate * delay from origin servers + cache hit rate * delay from satisfied at cache

**Cookies**
- used for 
	- authorization
	- shopping carts
	- recommendations
	- user sessions state
- set cookie (server to client), send cookie (client to server)
	- 1) cookie header line of HTTP response message (returned from server)
	- 2) put cookie in header line in the next HTTP request message 
	- 3) cookie file kept on user's host, browser manages
	- 4) backend database at web site 

### Data Control Plane
#### **1. Overview of the Network Layer**
The network layer consists of two major components:
- **Data Plane**: The per-router function responsible for forwarding packets from an input port to an output port.
- **Control Plane**: Network-wide logic that determines how packets are routed from source to destination.
--- 
#### **2. Two Key Network Layer Functions**
1. **Forwarding**:
   - Moving packets from a router’s input link to the correct output link.
   - Done via forwarding tables stored within routers.
2. **Routing**:
   - Determines the path a packet takes from source to destination.
   - Implemented using **routing algorithms** such as Dijkstra’s algorithm
#### **3. Data Plane vs. Control Plane**
### **Data Plane**:
- Operates at the individual **router level**.
- Handles **packet forwarding** based on header values.
- Uses a **forwarding table** to decide output ports.
#### **Control Plane**:
- Operates **network-wide**.
- Determines **how** routers should forward packets.
- Two approaches:
  - **Traditional Routing Algorithms**: Implemented directly in routers.
  - **Software-Defined Networking (SDN)**: Routing logic is handled by remote **controllers** that program forwarding tables in routers.
---
#### **4. Per-Router Control Plane vs. SDN Control Plane**
1. **Per-Router Control Plane**:
   - Each router runs its own routing algorithm.
   - Requires all routers to communicate and update routing tables.
2. **SDN (Software-Defined Networking) Control Plane**:
   - Centralized **remote controller** computes and installs forwarding tables.
   - Simplifies router hardware since decision-making is handled externally.

---
####  **5. Network Layer Service Models**
Different network architectures provide different **Quality of Service (QoS)** guarantees:
- **Internet (Best Effort Model)**: No guarantees on packet delivery, timing, or bandwidth.
- **ATM (Asynchronous Transfer Mode)**:
  - **CBR (Constant Bit Rate)**: Guaranteed bandwidth.
  - **ABR (Available Bit Rate)**: Guaranteed minimum bandwidth.
  - **IntServ (Integrated Services)**: Provides end-to-end bandwidth and delay guarantees.
  - **DiffServ (Differentiated Services)**: Prioritizes certain types of traffic.
---
## **6. Router Architecture**
A **router** consists of:
1. **Input Ports**:
   - Physical-layer termination.
   - Link-layer processing (e.g., Ethernet).
   - Packet forwarding lookup.
2. **Switching Fabric**:
   - Transfers packets from input to output ports.
   - Three types:
     - **Memory-based**: Uses CPU for switching.
     - **Bus-based**: Uses a shared communication bus.
     - **Crossbar-based**: Allows multiple simultaneous connections.
3. **Output Ports**:
   - Stores packets before transmission.
   - Includes **buffering and scheduling** mechanisms.
4. **Routing Processor**:
   - Executes control plane functions.
   - Manages routing algorithms and protocol processing.
---
#### **7. Input Port Functions**
Each input port in a router performs:
- **Line Termination**: Converts signals into packets.
- **Lookup & Forwarding**:
  - Uses the **forwarding table** to determine the next hop.
  - Can perform **destination-based forwarding** (traditional) or **generalized forwarding** (based on multiple header fields).
- **Queueing**:
  - If packets arrive faster than they can be forwarded, they are queued.
  - Can occur at **input** or **output** ports.
---
## **8. Longest Prefix Matching (LPM)**
- **Goal**: Forward packets to the correct interface using the **most specific** routing rule.
- **Process**:
  1. Convert IP addresses into binary format.
  2. Compare with prefixes in the **forwarding table**.
  3. Choose the longest matching prefix.
**Example**:

| Destination Address Range  | Link Interface |
| -------------------------- | -------------- |
| 11001000 00010111 00010    | 0              |
| 11001000 00010111 00011000 | 1              |
| 11001000 00010111 00011    | 2              |
| Otherwise                  | 3              |
- If an incoming packet has an IP of **11001000 00010111 00011000 10101010**, it will match **interface 1** due to the longest prefix match. 
---
#### **9. Forwarding & Routing Tables**
- **Forwarding Table**:
  - Contains mappings from destination addresses to output interfaces.
  - Used to forward packets efficiently.
- **Routing Table**:
  - Contains full path information.
  - Used by routing protocols to **compute** paths dynamically.
---
#### **10. Quiz Question Example**
**Q: A packet with IP address 150.12.218.51 arrives at a router with the following routing table. Which interface does it use?**

| Destination Address Range | Binary Representation                     | Interface |
| ------------------------- | ----------------------------------------- | --------- |
| 150.12.192.0/19           | 10010110 . 00001100 . 110xxxxx . xxxxxxxx | 1         |
| 150.12.0.0/16             | 10010110 . 00001100 . xxxxxxxx . xxxxxxxx | 2         |
| 150.12.216.0/21           | 10010110 . 00001100 . 11011xxx . xxxxxxxx | 3         |
| Default                   | -                                         | 4         |
**Answer**: The IP address **150.12.218.51** (binary: `10010110 . 00001100 . 11011010 . 00111000`) best matches **Interface 3**.
#### **Key Takeaways**
1. **The network layer has two main components**:
   - **Data Plane** (per-router forwarding).
   - **Control Plane** (network-wide routing).
2. **Forwarding moves packets within a router**, while **routing determines the overall path**.
3. **Software-Defined Networking (SDN)**:
   - Moves routing logic to a **remote controller**.
   - Makes routers simpler but requires external control.
4. **Routers have a structured architecture** with:
   - **Input ports, switching fabric, output ports**.
   - **Buffering and scheduling** mechanisms.
5. **Longest Prefix Matching (LPM)** is used in routing tables to find the best forwarding interface.
---
### CIDR and DHCP

#### **1. Network Layer and Addressing Problems**
 **IP Address Issues in the 1990s**
- **Two major problems:**
  1. **IP address exhaustion** – The available IPv4 addresses were running out.
  2. **Growing IP routing tables** – Large routing tables were difficult to manage and slowed down routing.
**Inefficiencies in Class A, B, and C Addressing**
- **Class B networks** were too large for most organizations, leading to wasted addresses.
- **Class C networks** were too small, leading to excessive fragmentation.
- The rapid allocation of Class B addresses indicated exhaustion by **1994**.
####  **Growth of Routing Tables**
- From **1991 to 1995**, routing tables doubled in size every **10 months**.
- This put significant stress on **router processing power and memory**.
---
#### **2. Solutions to IP Address Problems**

### **Short-Term Solutions**

- **Classless Inter-Domain Routing (CIDR)** was introduced to replace class-based addressing.

- **Private IP addresses** were set aside for internal networks.

  

### **Long-Term Solution**

- **IPv6** was introduced with a much larger address space.

  

---

  

#### **3. Classless Inter-Domain Routing (CIDR)**

---
### **4. Dynamic Host Configuration Protocol (DHCP)**
#### **Why DHCP?**
- **IP addresses can be assigned dynamically** instead of being manually configured.
- Supports **mobile users**, **address reuse**, and **automatic configuration**.
### **DHCP Process (Four Steps)**
1. **DHCP Discover** – Client broadcasts a request for an IP address.
2. **DHCP Offer** – Server responds with an available IP address.
3. **DHCP Request** – Client requests to use the offered IP.
4. **DHCP Acknowledge (ACK)** – Server confirms and assigns the IP.

### **Key Features of DHCP**
- **Supports address leasing** – Clients get an IP **only while connected**.
- **Can assign more than just an IP address**:
  - First-hop router’s IP address.
  - DNS server’s IP address.
  - Network mask.
### **DHCP in a Network**
- Typically, a **DHCP server is co-located with a router**.
- In **VLANs**, each VLAN has its own **DHCP server**.
#### **Broadcasting in DHCP**
- The DHCP server **broadcasts** the assigned IP to ensure all devices receive it.
- This is important when **multiple DHCP servers** are available.

#### **5. DHCP in Practice**
- **A laptop connecting to a network**:
  - Sends a **DHCP request**.
  - The **router running DHCP** assigns an IP.
  - The client receives:
    - **IP address**
    - **First-hop router address**
    - **DNS server address**
- **Encapsulation of DHCP messages**:
  - Sent in **UDP** (port 67, 68).
  - Encapsulated in **IP and Ethernet**.
###  **6. Key Takeaways**
- **CIDR solved IP address exhaustion** by allowing flexible subnetting.
- **CIDR reduced routing table size** significantly.
- **DHCP enables automatic IP address assignment**, reducing manual configuration.
- **DHCP provides more than just IP addresses**, helping with network configuration.



### Network layer control plane
- data plane: move packets from router's input to appropriate router output
- control plane: determine route taken by packets from source to destination
- **per router control plane:** individual routing algorithm components in each and every router interact in the control plane
- **software defined networking control plane:** remote controller computes, installs forwarding tables in routers

- 
- Counting to infinity problem of DV routing
	- nodes believe best path is through each other
	- ![[Screenshot 2025-03-26 at 2.50.21 PM.png]]
- Poisoned reverse:
	- if a neighbour is selected as the next node to destination => to that neighbour, report infinite distance to the destination
![[Screenshot 2025-03-26 at 2.57.04 PM.png]]
	- ![[Screenshot 2025-03-26 at 3.24.47 PM.png]]
- Comparison of LS and DV algorithms
	- message complexity:
		- LS: n routers, O(n^2) messages sent
		- DV: exchange btw neighbours
	- speed of convergence:
		- LS: O(n^2) algorithm, O(n^2) messages, may have oscillations
		- DV: convergence time varies, may have routing loops, count to infinity problem problem
	- robustness (if router malfunctions, or is compromised):
		- LS: router can advertise incorrect link cost, each router computes only its own table
		- DV: router can advertise incorrect path cost (black holing), each router's table used by other's, error propagates through network
- Preferred Link State
	- fast, loopless convergence
	- less routing information for transmission to neighbour nodes
	- support for precise metrics
	- support for multiple paths to a destination



BGP (Border Gateway Protocol): the de-facto inter domain routing protocol
- allows subnet to advertise its existence and the destinations it can reach
- BGP provides each AS a means to 
	- exterior BGP: obtain subnet reachability 
	- interior BGP: propagate reachability information to all AS-internal routers, determine good routes to other networks based on reachability information and policy
- BGP basics
	- BGP session: 2 BGP routers exchange BGP messages over semi permanent TCP connection
	- when AS3 gateway 3a advertises path AS3,X to AS2 gateway 2c
		- AS3 promises to AS2 it will forward datagrams towards X


eBGP. iBGP connections
- you have multiple ASs
- gateway routers run both eBGP. iBGP
- BGP session: 2 routers exchange BGP messages over semi permanent TCP connections
- when AS3 gateway (gateway router), telling another gateway router to inform them of the presence of another network (X)
- BGP advertisement AS3, X
- BGP is a path vector protocol, advertising paths to different destination network prefixes

BGP advertised route" prefix + attributes
- prefix: destionation being advertised
- 2 important attributes
	- AS-path: list of ASs through which prefix advertisement has passed (how many ASs i have to travel through to get to destination)
	- NEXT HOP: indicates (which gateway router internal to your AS) do you have to travel to to get to destination
- policy based routing:
	- gateway receiving route advertisement uses import policy to accept / decline path
	- AS policy also determines whether to advertise path to other neighboring ASs
- AS2 router 2c receives path advertisement AS3,X from AS3 router 3a
- based on AS2 policy AS2 router 2c accepts path AS3,X propagates (via iBGP) to all AS2 routers
- informs other routers internal to AS that you can get to destination through me (gateway router)
- there can be multiple paths to destination
	- AS1 gateway router 1c learns path AS2, AS3, X from 2a
	- AS1 gateway router 1c learns path AS3, X from 3a
	- based on policy , you choose the path
- path attributes are important  cuz it allows checking for routing loops, allows receiver to implement policy constraints , allows a receiver to know al sources
- BCP messages exchanged btw peers over TCP connection
- BCP messages
	- OPEN: opens TCP connection 
- BCP you dont care about cost (internally you care about cost)

BCP path advertisement 
- OSPF intra routing: to get to 1c use interface 1
- to get to X use interface 1
- policy
	- inter AS: admin wants control over how its traffic routed, who routes through its network
	- intra AS: single admin, so policy less of an issue
- scale:
	- hierarchical routing saves table size, reduces update traffic
- perforamnce:
	- intra-AS: can focus on performance
	- inter-AS: policy dominates over performance (sending to another AS, u dont care how it travels)
- hot potato routing (packet is too hot, you send it to first gateway (closest gateway))
	- 2d learns it can route to X via 2a or 2c
	- choose local gateway that has least intra domain cost
- BGP:  achieving policy via advertisements
	- A,B,C are provider networks
	- x,w,y are cutomsers
	- ISP only wants to route traffic to/from its customer networks (does not want to carry transit traffic btw other ISPs - a typical "real world" policy)
	- A advertises path Aw to B and to C
	- B forwarded a packet from y to w
	- B will say i might not advertise a path (BAw)to C
	- policy to enforce: x does not want to route from B to C via x
		- so x will not advertise to B a route to C
- BGP hijacking
	- advertises that its the closest, dumps it into a black hole

### Link Layer
- layer 2 packet: frame, encapsulates datagram
- link layer has responsibility of transferring datagram from one node to **physically** adjacent node over a link
- services:
	- encapsulates datagram into frame, adding header and trailer
	- channel access if shared medium
	- MAC addresses in frame headers identify source, destination (different from IP address)
	- each computer has its own MAC address, wifi vs ethernet has its own MAC address 
	- unique inside your network
- reliable delivery btw adjacent nodes
	- seldomly used on low bit error links
	- wireless links: high error rates
	- why both link level and end end reliability?
- flow control
	- packing btw adjacent sending and receiving nodes
- error detection:
	- signal attenuation or noise
	- receiver detects errors / signals
- error correction:
	- receiver identifies and corrects bit error without retransmission
- half duplex and full duplex:
	- with half duplex, nodes at both ends of link can transmit, but not at same time
#### where is link layer implemented?
- each and every host
- implemented in Network interface card or on a chip
- ethernet, wifi card, chip
- attaches into hosts system buses
- combination of hardware, software, firmware

	8 octets - preamble (synchronization of the clock)
	6 - dest address (MAC address)
	6 - sources address (MAC address)
	2- length 
	46-1500 octets (data)
	4 - CRC (cycle redundancy check) added to the tail
	
Error detection
- error detection and correction bits
- D: data projected by error checking, may include header fields
- if all bits in D' ok? 
	- if NO then detected error
	- if YES then send it to network layer
- how do we reduce the probability of sending an erroneous packet
	- parity checking: detect single bit errors (even parity: set parity bit so there is an even number of 1s)
	- 2d bit parity
		- detect and correct single bit errors
		- there is row and column parity
		- can know where it happens and check 
 - internet checksum
	 - goal: detect errors
	 - sender:
		 - treat contents of UDP segment (including UDP header fields) and IP addresses as sequence of 16 bit integers
	 - checksum: addition of segment content
	 - checksum value:
	 - cyclic redundancy check:
		 - D: data bits (binary numbers)
		 - G: bit pattern (generator) of r+1 bits
		 - use those generators 
	 - < D, R >, there is r CRC bits
	 - < D, R > = D.2^r (XOR) R
	- goal: choose r CRC bits R, such that <D,R> exactly divisible by G (mod 2)
		- receiver knows G, divides <D,R> by G, if non-zero remainder detected!
		- can detect all burst errors 
	- we want D $\cdot$ 2^r XOR R = n G (multiple of G)
	- R = remainder [(D2^r)/G]
	- 2^r is a left shift, (g is 4 bits, we do 3 bit shift)
	- Rmb its XOR operation, not subtract in binary division
	Polynomial representation
	- binary = 1011,  g(x) = x^3 + x + 1
	- binary = 1100, g(x) = x^3 + x^2
	- shift:
		- x^3g(x) = x^3(x^3 + x + 1) = x^6 + x^5
	- example : 
		- x^n + x^n = 2(mod2) x^n = 0
		- x^m + x^m + x^m = 3(mod2) x^m = x^m
	- they must all satisfy this pattern:
		- b(x) = x^{n-k} i(x) + r(x)
	- receiver must know g
	Shift register implementation
		- information bits $i_{k-1}, i_{k-2}, \cdots, i_2, i_1, i_0$
- More on error detection 
	- $i(x) = x^7 + x^4 + x^3 +x^2 +1$
	- $g(x) = x^3 + 1$
	- $x^3 i(x) = x^{10} + x^7 + x^6 + x^5 +x^3$
	- do the long division
	- Transmitted bits : DATA <= {10011101}{100} => CRC code
	- if there is a remainder and not 0, it means that we have detected an error
	- objective is to design g(x) such that we can catch the most amount of errors
	- how to detect 2 bit errors? 
		- no with current CRC
		- transmitted bits: b(x)
		- received bits: d(x) = b(x) + e(x) where e(x) is the error pattern
		- receiver divides d(x) by g(x):
			- remainder[d(x)/g(x)] = 0 => no error
			-  remainder[d(X)/g(x)] != 0 => error
			- an error cannot be detected if e(x) divides g(x) since
				- remainder[d(x)/g(x)]  = remainder[d(x)/g(x)] = remainder[e(x)/g(x)]
				- if my error bit pattern also divides by g(x) then you cannot detect the error
		- 1 bit error
			- e(x) = x^n. , e = 0...0100000
			- to guarantee it: the generator polynomial g(x) should have the term 1, i.e 
				- g(x) = x^m + ... + 1
				- no error pattern x^n is divisible by g(x)
			- example: cannot find any polynomial q(x) to satisfy x^6 != q(x)(x^3 +1)
		- 2 bit error
			- e(x) = x^k (x^n + 1)
			- 2 erroneous bits are n bits apart
			- we only consider e(x) = x^n + 1 since x^k has been taken care of by a 1 bit error case
			- we know that e(x) is not divisible by x^k for any k
			- hence to make sure all 2 bit errors can be detected the error pattern of the form e(x) = x^n + 1
			- how to catch?
				- primitive polynomials g(x) of order  m is a primitive polynomial if the smallest positive integer n such that g(x) divides (x^n + 1) is n = 2^m - 1
				- g(x) = x^2 + x + 1 is a primitive polynomial
					- x^3 + 1 = (x+1)(x^2+x+1), m=2, n=3
					- any error polynomial of degree 2 or smaller can be detected in other words if the 2 error bits are closer than 3 bits
			- make sure these 2 conditions are satisfied
				- 1. select a primitive polynomials as the generating polynomial
				- 2. the maximum length of the packet, n should be selected to be smaller than n < 2^m - 1
			- for a 2 bit error the error polynomial is e(x) = x^n -1
		- odd number of errors
			- if the polynomials has the term (x+1) all odd number of bit errors can be detected
			- no polynomial q(x) can be found to hold in:
				- x^7 + x^4 + 1 != q(x)(x+1)
		- burst of errors:
			- a burst of errors generates a polynomial e(x)
			- if the degree of e(x) is smaller than the degree of the generating polynomial then e(x) will not be divisible by g(x)
		- multiplication of polynomails
			- g(x) = (x+1)p(x), where p(x) is a primitive polynomial
			- (x+1)(x^15 + x + 1) = x^16 + x^15 + x^2 + 1
			- what is the size of the packet you can send?
				- 2^15

Multiple Access Protocols
- point to point
	- point to point link between Ethernet switch, host
	- PPP for dial up access
- broadcast (shared wire or medium)
	- old fashioned ethernet, upstream HFC in cable based access network
- single shared broadcast channel
- MAC protocols
	- channel partitioning: divide channel into smaller pieces (allocate piece to node for exclusive use), can be time slots, frequency, code
	- random access: channel not divided, allow collisions, recover from collisions
	- taking turns: nodes take turns but nodes with more to send can take longer turns
- Channel Partitioning
	-  TDMA
		- access to channel in rounds
		- each station gets fixed length slot (length = packet transmission) in each round
		- unused slots go idle
	- FDMA
		- channel spectrum divide into frequency bands
		- each station assigned fixed frequency band
		- unused transmission time in frequency bands go idle
		- example: 6 station LAN, 1,3,4 have packet to send, frequency bands, 2,5,6 idle
- Random Acces Protocols
	- when node has packet to send
		- transmit at full channel data rate R
		- no a priori coordination among nodes
	- 2 or more transmitting nodes can cause collision
	- we resolve collisions with retransmissions
	- we specify how to detect collisions
	- how to recover from collisions (delayed retransmissions)
-  if there is a collision, the 2 packets are lost need to be retransmitted, CRC is corrupted
- this is wrt same channel and same frequency
- ALOHANet: 
	- pure (uslotted) ALOHA
		- efficiency
		- P(success by given node) = P(node transmits) P(no other node transmits in \[$t_0 - 1, t_0$\]) P(no other node transmits in \[$t_0, t_0$ + 1\])
		- $p (1-p)^{N-1} (1-p)^{N-1}$
		- slotted ALOHA: no partial collision, either full collision or no collision
		- all frames have the same size
		- time divided into equal size slots
		- nodes start to transmit only at beginning of slot
		- operations
			- when node obtains a new frame, transmits in next slot
			- if no collision: node can send new frame in next slot
			- if collision: node retransmits frame in each subsequent slot with probability **p** 
	- successful timeslots: 
	- idle timeslots: nobody sending stuff
	- Binomial 
		- $p(X=k) = {N \choose k} p^k (1-p)^{N-k}$
		- N = number of nodes / computers
		- idle slot $= p(X = 0)$
		- success slot $= p(X = 1)$
		- collision slot $= p(X \ge 2)$
		- from perspective of 1 node:
			- Probability of success for 1 node: $P_s = p (1-p)^{N-1}$
			- all other nodes must be quiet

CSMA (carrier sense multiple access)
- CSMA: listen before transmit
- if channel sensed idle: transmit idle frame
- if channel sensed busy: 
	- **1 persistent:** keep sensing till channel becomes idle then transmit
	- **p persistent:** wait till channel becomes idle, then transmit with probability p and wait a time slot with probability (1-p)
	- **non persistent:** relinquish the channel, wait a random time and come back and sense the channel again
	- theres an issue with 1 persistent, cuz if there are 2 nodes using 1 persistent then it will be greedy and send right away result in for sure collision
- collisions can still occur with carrier sensing
- propagation delay means 2 nodes may not hear each-other's just started transmission
- entire packet transmission time is wasted
- note it is NOT possible for wireless transmission to send receive and sense at the same time, wired you can
- collision detection
	- wired LANs: measure signal strengths, compare transmitted received signals
	- wireless LANs: received signal strengths overall strength overwhelmed by local transmission length
- CSMA/CD reduces the amount of time wasted in collisions
- Ethernet CSMA / CD algorithm
	- NIC receives datagram from network layer, creates frames
	- NIC senses channel:
		- if idle: start frame transmission
		- if busy: wait until channel idle, then transmit
	- NIC transmits entire frame without collision, NIC is done with the frame
	- if NICE detects another transmission while sending: abort send **jam** signal
	- after aborting NIC enters exponential backoff
		- after mth collision , NIC chooses K at random from {0,1,2,...,2^m-1}
		- NIC waits K X 512 bit times, returns to step 2
- CSMA / CD efficiency
	- T_prop = max prop delay btw 2 nodes in LAN
	- T_trans = time to transmit max size frame
	- efficiency $= \frac{1}{1 + 5 \frac{t_{prop}}{t_{trans}}}$
	- can only run this in short distances
	- better performance than ALOHA
- Taking turns MAC protocols
	- channel partitioning MAC protocols
		- share channel efficiently and fairly at high load
		- inefficient at low load: delay in channel access, 1/N bandwidth allocated even if only 1 active node
	- random access MAC protocols
		- efficient at low load: single node can fully utilize channel
		- high load: collision overhead
	- taking turns protocols
		- look for best of both worlds
- Approach
	- find t_trans, t_prop
	- find efficiency
	- usable bandwidth * efficiency
	- divide by transmission rate of each computer

Ethernet frame structure![[Screenshot 2025-03-27 at 4.44.17 PM.png]]
 - preamble: synchronize receiver, sender clock rates
 - 7 bytes of 10101010 followed by one byte of 10101011
 - excluding preamble: minimum ethernet frame size = 64 bytes, maximum ethernet frame size = 1518 sizes
 - addresses: 6 byte source, destination MAC addresses
 - type: indicates higher layer protocol
	 - mostly IP but others possible, used to demultiplex up at receiver

Why is there a minimum size of 64 bytes?
- because ewe need a minimum sensing interval


MAC addresses:
- 32 bit IP address
- network layer address for interface
- used for layer 3 (network layer) forwarding
- e.g. 128.119.40.136
- MAC address:
	- function: used locally to get frame from one interface to another physically connected interface (same  , in IP addressing sense)
	- 48 bit MAC address burned in Network Interface Card ROM, also sometimes software settable
	- 6 bytes in HEX, every 4 bits make up 1 character
	- 6 different octets
- each interface on LAN
	- has unique 48 bit MAC address
	- has a locally unique 32 bit IP address
- hexadecimal representation
	- MAC-48 address in human friendly form is six groups of two hexadecimal digits
	- it is expected that the MAX- 48 addresses space to be exhausted no sooner than the year 2100
- address allocation administered by IEEE
- manufacturers buys portion of MAC address space (to assure uniqueness)
- MAC flat address: portability
	- can move interface from one LAN to another
	- recall IP address **not portable**, depends on IP subnet to which node is attached
- universal and local addresses
	- addresses can either be **universally administered addresses** or **locally administered addresses**
- A universally administered address is uniquely assigned to a device by its manufacturer and burned into the device
- Types
	- Unicast: 
	- Broadcast: if you want all computers in that network to receive that packet
	- Multicast: not all computers but a group of computers is expected to receive that packet
- Format:
	- ![[Screenshot 2025-03-31 at 4.23.38 PM.png]]
	- first 3 bytes have to be purchased by the company
-  How to learn MAC address
	- 2 machines on a given physical network can communicate only if they know each others physical address
- Address Resolution Protocol:
	- How to determine interface's MAC address, knowing its IP address
	- Target HA field in the ARP request message is filled with NOT FFF stuff, the destination address holds the FFF stuff
	- ARP table: each IP node (host, router) on LAN has an ARP table
		- IP/MAC address mappings for some LAN nodes
		- TTL (Time to Live): time after which address mapping will be forgotten (typically 20 min)
	- A broadcasts ARP query, containing B's IP address, B's MAC address is not in A's ARP Table, so A uses ARP to find B's MAC address
		- destination MAC address = FF-FF-FF-FF-FF-FF
		- all nodes on LAN receive ARP query
	- B replies to A with ARP response, giving its MAC address
	- A receives B's reply, adds B entry into its local ARP table

![[Screenshot 2025-03-31 at 4.35.49 PM.png]]

Routing to another subnet: addressing
- sending a datagram from A to B via R
- focus on addressing - at IP (datagram) and MAC layer (frame) levels
- assume that:
	- A knows B's IP: DNS
	- A knows IP address of first hop router, R: DHCP / default gateway
	- A knows R's MAC address: ARP
- A creates IP datagram with IP source A, destination B
- A creates link layer frame containing A to B IP datagram
- R's MAC address is frame's destination
- MAC address is on your own network, so MAC destination is the router MAC
![[Screenshot 2025-03-31 at 4.46.07 PM.png]]
- What could go wrong if we didn't have MAC addresses and only used IP addresses inside a LAN?
	- all nodes had to process ALL the packets at the network layer to verify whether they had been addressed to them. the OS on those computers would be busy processing packets

### Hubs and Switches
- Hub is a repeater, physical layer device
- Signal regeneration, all traffic appears in both LANs
- Switch is a link layer device, performs MAC address filtering, local traffic stays in own LAN
	- has an active role, it selectively forwards frames to one or more outgoing links when frame is to be forwarded on segment, uses CSMA to access segment
	- transparent: hosts / users unaware of presence of switches
	- plug and play, self learning, switches do not need to be configured
	- Multiple simultaneous transmissions
		- hosts have dedicated direct connection to switch
		- switches buffer packets
		- ethernet protocol used on each incoming link, no collisions full duplex, each link is its own collision domain
		- collision does not happen btw nodes, only btw switch and node
		- if 2 hosts try to send to same machine, it cannot happen simultaneously, need to schedule or do Store and Forward
	- Switch forwarding table
		- each switch has a switch table (initially empty)
		- MAC address of host, interface to reach host, timestamp
		- how are entries created, maintained?
			- similar to routing protocol
			- switch learns which hosts can be reached through which interfaces
			- when frame received, switch learns location of sender (looking at source), incoming LAN segment
			- records sender location pair in switch table
			- index switch table using switch table using MAC destination address
			- if entry found for destination
				- if destination on segment from which frame arrived
					- drop frame
				- else: forward packet to the direction you want
			- else: flood 
	- interconnecting switches
		- self learning switches can be connected together
	- routers: network layer devices (examine network layer headers)
	- switches: link layer devices (examine link layer headers)
	- both switches and routers have forwarding tables
		- routers: compute tables using routing algorithms, IP addresses
		- switches: learn forwarding table using flooding, learning, MAC addresses
	- we do not replace routers with switches in large campus networks cuz the size of switch table will be extremely large, frequent flooding in the network will waste resources

### Virtual LANs
- single broadcast domain:
	- scaling: all layer 2 broadcast traffic must cross entire LAN
	- efficiency, security, privacy issues
	- organize different LANs, these LANs even tho physically they may be in separate places but they are the same broadcast domain
- virtual LANs: switches supporting VLAN capabilities can be configured to define multiple virtual LANs over single physical LAN infrastructure
- Port based LANs
	- each port has a colour, belongs to a group / VLAN, operates as multiple virtual switches
	- traffic isolation: frames to/from ports 1-8  can only reach ports 1-8
- dynamic membership: ports can be dynamically assigned among VLANs
- forwarding between VLANs: done via routing (just as with separate switches)
- you can also have VLANs spanning multiple switches
- you can have a trunk port (no colour assigned), used to carry frames btw VLANs defined over multiple physical switches (can carry blue or red traffic)
	- frames forwarded within VLAN between switches cannot be vanilla 802.1 frames (must carry VLAN ID info)
- trunking in VLAN
	- frames from different VLANs are exchanged over the same trunk, VLAN ID field identifies the frames for each VLAN
- VLAN has same broadcast domain - these groups of computers of a certain network to receive all of the same packets
- Multi-protocol Label Switching (MPLS)
	- goal: high speed IP forwarding among network of MPLS capable routers, using fixed length label
	- faster look up using fixed length identifier
	- borrowing ideas from virtual circuit approach
	- but IP datagram still keeps IP address
	- MPLS capable router
		- forward packets to outgoing interface based only on label value (don't inspect IP address)
		- MPLS forwarding table distinct from IP forwarding table
		- flexibility:
			- use destination and source addresses to route flows to same destination differently 
			- reroute flows quickly if link fails
		- IP routing: path to destination determined by destination address alone
		- MPLS routing: path to destination can be based on source and destination address
			- flavour of generalized forwarding 
			- fast remote: precompute backup routes in case of link failure
- MPLS and IP tunneling
	- in MLPS all frames follow the same route over the MPLS network the route should be established before the start of the communication
	- MPLS needs route reservation before the start of communication
	- In IP tunnelling, the source and the destination of the tunnel are fixed 
- MPLS signalling
	- modify OSPF link state flooding protocol to carry info used by MPLS routing
	- link bandwidth, amount of reserved link bandwidth
	- entry MPLS router uses a reservation signalling protocol to set up MPLS forwarding

Difference btw POST and PUT requests:
- POST is used to create a new resource on the server
- PUT: is used to update an existing resource or create it if it doesn't exist
- Idempotency:
	- HTTP method is **idempotent** if the intended effect on the server of making a single request is the same as the effect of making several identical requests




## Active Learning
---

How long does it take to transmit the whole file if it is broken into 4 equal-size packets and each packet is transmitted independently (If we use SF or CT)? 
%%SF: 48 sec, CT: 32 sec%%

---

A file of size L=4000 Bytes is transmitted on an end-to-end connection over 3
links. The bit rate of all links is R=1000 bit/sec. Ignore the propagation delay. How long does it take for the file to be received at the destination if the whole file is transmitted as a single packet and the routers are store-and-forward? How long does it take for the file to be received at the destination if the whole file is transmitted as a single packet and the routers are cut-through?

---

What is the total delay for store-and-forward andcut-through switching if there are N routers?

---

 In which model packets are more likely to be lost in the network?
![[Screenshot 2025-03-04 at 1.17.37 PM.png]]

---
A is an HTTP client, B is a web server (more in the next chapter). A sends a GET
packet to receive a file of size 1000 bytes and the GET packet is 50 bytes. The
transmission rate of the links is 8 Kbit/sec. The router has a random processing and queuing delay uniformly distributed in the interval \[0, 200msec\]. The router uses S&F switching. Find the minimum and maximum delays to fetch the file. What is the average delay? Ignore the propagation delay.

---

Minion wants to design a new File Transfer Protocol (FTP). Help him find the best transport protocol.
(a) He has to use TCP because it has congestion control.
(b) He has to use TCP because it is a reliable service.
(c) He has to use UDP because FTP is elastic and does not need connection setup.
(d) He has to use UDP because file transfer can tolerate delay and does not need timing.

---
By looking at the header of the packet can you say to which application it is going?

---

Consider the following two statements:
I. In the client-server paradigm, a server might be idling for an extremely long (almost infinite) interval of time.
II. In peer-to-peer file sharing, different fragments of a file might be downloaded from different peers.


---

A web page has two pictures.
(a) Find the time (in terms of RTT) it takes to retrieve the web page if the two pictures are on two different servers and non-persistent HTTP is used. (no parallel connections)
(b) Solve the same problem for persistent HTTP.
(c) What if only one of the pictures is on a different server.

---

Assume instead of using a cache, we increase the rate of the outgoing link to 154 Mb/s. What would be the average total delay in fetching files? If the user is authenticated by using the username and password, do we still need to use cookies?
%% jhelasd %%


---
Which one of the following statements is correct?
A. Cookies are not used unless when the HTTP runs on UDP to make sure that a state for the connection is maintained.
B. For Cookies to be effective a local cookie file should be maintained by the browser.
C. Cookies can only be used when the programmer is hungry.
D. The web server checks the content of the Cookie and will not reply to the client HTTP protocol if the same website was already downloaded by the client.

---

Consider the following two statements :
(I) Email clients may use either IMAP or POP3 to send and receive emails.
(II) SMTP uses 7-bit ASCII messages over a TCP connection to send emails.

---

Can we use SMTP, instead of IMAP, to retrieve emails from the server?

---

What happens if the mail message has a single dot on a line?

---
I. Two DNS requests for the same website that are 1 second apart always have the same address resolution time.
II. DNS uses a client-server paradigm.

---
Suppose within your web browser you click on a link to obtain a web page. The IP address is not cashed and the root, TLD, and authoritative servers should all be visited to resolve the IP address. Assume that the one-way propagation delay
between your computer and the local DNS server is 1 msec and the one-way propagation delay in the internet is 5 msec. Assume that the web page you are
fetching has one image located on a different server in the same company. How long does it take to resolve the IP address of the web page and all objects?

---
Consider the following two statements:
I. P2P can help content providers with small uplink bandwidth to distribute their content easily.
II. When two nodes become peers in Bit Torrent, they will stay peers until both nodes receive all the chunks of the same file.


---
- All keys are distributed uniformly at random in the key range
- The query for any key is generated with the same probability.
- Each P2P link has a delay of 1 second.
- All 8 peers are responsible for the same number of queries on average
Q: What is the average search time in the system?![[Screenshot 2025-03-04 at 1.07.27 PM.png]]


---
Consider the following two statements:
I. The minimum distribution time in P2P increases with the number of participating nodes.
II. The number of copies of the file among the peers increases faster than linear in P2P file sharing.

---
How does the receiver know that the transmitter has used checksum?

---
Why does TCP need to work with 4 tuples?

---
A file of size 40,000 Bytes is transmitted on a connection with the bit rate of R=400,000 bit/sec and the one way propagation delay of 5msec. Assume that a header of 50 Bytes is added to each packetand assume that the maximum packet size (including the header) in the network is limited to 450 Bytes. Ignore the processing delay and assume that the size of the ACK packet is 50 Bytes. If Stop-and-Wait ARQ is used, how long does it take to transmit the file? Assume an error-free communication.

---
In the following example assume Go-Back-3 is used, what will be the sequence numbers and the ACK numbers? Assume m = 2, where m is the number of bits at the header used for the sequence number.![[Screenshot 2025-03-04 at 1.02.45 PM.png]]


---

Assume, 1 Gbps link, 15 ms propagation delay, 8000 bit packet. How long does it take to transmit a file of size 100,000 Bytes if Go-Back-4 is used. Ignore the header size and assume error-free.![[Screenshot 2025-03-04 at 1.01.55 PM.png]]


---

If Selective-Repeat with Ns=3 and Nr=2 is used, what will be the sequence numbers and the ACK numbers? Use cumulative ACK. Assume m = 4.![[Screenshot 2025-03-04 at 1.00.40 PM.png]]


---

 In the figure below, TCP transmits packet with the given sequence numbers on a 10Mb/sec link. At time T1, EstimatedRTT = 16msec, and DevRTT= 8msec. All values on the figure are in msec.![[Screenshot 2025-03-04 at 1.00.13 PM.png]]


---
In the occasion of impending congestion, should the router set the ECN of all flows or a subset of them?

---
If flow control is properly executed, there will be no loss of information in the network.

---

What is the benefit of moving some responsibilities of TCP (e.g. congestion control and error control) to the application layer?

---

A file of size 5000 Bytes is transmitted on a TCP connection with the one way propagation delay of 5msec. Ignore the processing delay and the header size, and assume that the size of the ACK packet is negligible. No packet is lost in the network. Maximum segment size is 250 Bytes. Ignore the TCP connection establishment and tear-down time. What will be the total time required to transmit the whole file after the GET command has been received at the server if the link bandwidth is infinity?



